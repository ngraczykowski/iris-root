buildscript {
  repositories {
    mavenCentral()
  }
}

plugins {
  id "idea"
  id "maven-publish"
  id "com.silenteight.gradle.convention" version "1.15.0"
  id "com.silenteight.gradle.release" version "1.0.9"
  id "com.silenteight.gradle.wrapper" version "1.0.25"
  id "com.silenteight.gradle.testreportspublisher" version "1.1.0"
  id "io.freefair.aspectj" version "5.0.1" apply false
  id "nebula.resolution-rules" version "7.6.0"
  id "org.sonarqube" version "2.8"
}

projectSetup {
  javaVersion = JavaVersion.VERSION_11
}

idea {
  module {
    [".gradle", "build"].each {
      excludeDirs += file("$projectDir/$it")
    }
  }
}

ext {
  // Java
  sourceCompatibility = JavaVersion.VERSION_11
  targetCompatibility = JavaVersion.VERSION_11
  gradleScriptDir = "${rootProject.projectDir}/gradle/scripts"
}

apply from: "${gradleScriptDir}/resolutionRules.gradle"

subprojects {Project project ->
  pluginManager.withPlugin("java") {
    project.apply from: "${gradleScriptDir}/dependencies.gradle"

    project.pluginManager.apply "io.freefair.aspectj.post-compile-weaving"

    project.dependencies {
      implementation libraries.jaxb_api
    }

    project.aspectj {
      version = libraries.aspectjtools.version
    }

    project.tasks.named(JavaPlugin.COMPILE_JAVA_TASK_NAME).configure {JavaCompile java ->
      def processResources = project.tasks.named(JavaPlugin.PROCESS_RESOURCES_TASK_NAME)

      java.dependsOn processResources
    }

    project.tasks.withType(JavaCompile).configureEach {JavaCompile java ->
      java.options.fork = true
    }

    project.mavenPublish {
      artifactId = "${project.name}"
      artifactName = "${project.description}"
    }
  }
}

configure(subprojects) {Project subproject ->
  subproject.pluginManager.withPlugin("java") {
    subproject.afterEvaluate {
      if (!subproject.pluginManager.hasPlugin("java-library"))
        generateClassPathInManifest(subproject)
    }
  }
}

static def generateClassPathInManifest(Project project) {
  // Generates Class-Path in .jar manifest
  project.tasks.named(JavaPlugin.JAR_TASK_NAME).configure {Jar jar ->
    jar.doFirst {
      jar.manifest {
        def runtimeClasspath = project.configurations.runtimeClasspath

        if (!runtimeClasspath.isEmpty()) {
          def classPathJars = runtimeClasspath.collect {it.getName()}.join(" ")

          attributes "Class-Path": classPathJars
        }
      }
    }
  }
}
