# Recommending alerts

Alert recommendation is made of recommendation comment and recommended action, and requires the following:

- Recommended action
  - Match solutions
      - Features
      - Categories
      - Solving strategy
- Features
- Categories
- Comment inputs

Recommended action is retrieved from Governance API, as an input taking solutions of all matches, as well as a solving strategy.

Solving strategy comes from analysis and is passed over to Governance API along with match solutions, using synchronous gRPC call.

Match solutions are generated by Governance API, using synchronous gRPC call.

Comment inputs come from the Data Source API, using synchronous gRPC call.

Features come from agents, via asynchronous, RabbitMQ-delivered requests.

## Basic use cases

### Generating recommendations for alerts

To generate alert recommendation, client must:

- create alerts and matches,
- create an analysis,
- create a dataset from these alerts,
- add a dataset to an analysis.

### Generating additional recommendations in existing analysis

To generate recommendations for more alerts, client can:

- create additional alerts and matches,
- create a dataset with additional alerts,
- add the dataset to previously created analysis.

### Regenerating alert recommendations

To trigger alert recommendation regeneration, client must:

- remove recommendation from analysis.

This will trigger re-evaluation of analysis and its alerts that are missing recommendation.

## Technical design

> **CAUTION**
>
> This section is under development.

The list of integration flows that would result in solving alerts:

```
+ AddDatasetRequest (grpc) -> AnalysisDatasetsAdded (rabbit)

+ BatchAddDatasetsRequest (grpc) -> AnalysisDatasetsAdded (rabbit)

+ AnalysisDatasetsAdded (rabbit) -> List<PendingRecommendation> (db) -> PendingRecommendations (rabbit)

+ PendingRecommendations (rabbit) -> List<AgentExchange> (db) -> List<AgentExchangeRequest> (rabbit)

+- AgentExchangeResponse (rabbit) -> List<MatchFeatureValue> (db) -> (-) (TODO ISSUE) MatchFeaturesUpdated (spring)

+ PendingRecommendations (rabbit) -> BatchGetMatchCategoryValuesRequest: BatchGetMatchCategoryValuesResponse (grpc) -> List<MatchCategoryValue> (db) -> MatchCategoriesUpdated (spring)

+ PendingRecommendations (rabbit) -> StreamCommentInputsRequest: List<CommentInput> (grpc) -> List<AlertCommentInput> (db) -> CommentInputsUpdated (spring)

? MatchCategoriesUpdated (spring) -> SolveMatchesCommand (spring)

? MatchFeaturesUpdated (repeated matches) (spring) -> SolveMatchesCommand (analysis_id) (spring)

- SolveMatchesCommand (spring) -> BatchSolveFeaturesRequest: BatchSolveFeaturesResponse (grpc) -> List<MatchSolution> (db) -> MatchesSolved (rabbit)

? MatchesSolved (spring) -> RecommendAlertsCommand (spring)

? CommentInputsUpdated (spring) -> RecommendAlertsCommand (spring)

? PendingRecommendations (rabbit) -> RecommendAlertsCommand (spring)

RecommendAlertsCommand (spring) -> BatchSolveAlertsRequest: BatchSolveAlertsResponse (grpc) -> List<Recommendation> + delete PendingRecommendation (db) -> RecommendationsGenerated (rabbit)
```

A
- M1
- M2

M1
- CV1 - AE
- CV2 - DENY
- FV1 - WEAK_MATCH
- FV2 - MATCH
- FV3 - NO_MATCH

To get Match Solution for M1:
- Request a solution from Gov for: AE, DENY, WEAK_MATCH, MATCH, NO_MATCH (feature vector), with policy "policies/xxxxxx".
- **How do we know which matches are ready to be asked for?**
- 

WHAT IS NEEDED FOR ANALYSIS:

- C1, C2, F1, F2, F3

WHAT WE HAVE FOR MATCH:

- C1, F2, F3


> **TODO**
>
> The missing part **might be** the PendingMatchSolution.
>
