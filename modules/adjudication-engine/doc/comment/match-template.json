{
  "templateName": "match.ftl",
  "revision": 6,
  "template": "<#import \"match-utils.ftl\" as matchUtils>\n<#import \"name-agent.ftl\" as nameTemplate>\n<#import \"organization-name-agent.ftl\" as organizationNameTemplate>\n<#import \"organization-name-agent.ftl\" as organizationName2Template>\n<#import \"geo-agent.ftl\" as geoTemplate>\n<#import \"geo-agent.ftl\" as geo2Template>\n<#import \"missing-agent.ftl\" as missingAgentTemplate>\n<#import \"name-matched-text-agent.ftl\" as nameMatchedTextTemplate>\n<#import \"historical-agent-tp.ftl\" as historicalRiskAccountNumberTPTemplate>\n<#import \"historical-agent-fp.ftl\" as historicalRiskAccountNumberFPTemplate>\n<#import \"contextual-agent-fp.ftl\" as contextualLearningNameFPTemplate>\n<#import \"contextual-agent-tp.ftl\" as contextualLearningNameTPTemplate>\n<#import \"nationality-agent.ftl\" as nationalityTemplate>\n<#import \"residency-agent.ftl\" as residencyTemplate>\n<#import \"gender-agent.ftl\" as genderTemplate>\n<#import \"national-id-agent.ftl\" as nationalIdTemplate>\n<#import \"date-agent.ftl\" as dateTemplate>\n<#import \"passport-agent.ftl\" as passportTemplate>\n<#import \"document-agent.ftl\" as documentTemplate>\n\n<#-- If the given feature is not listed here, then the comment for this feature will be added just\nafter features that are included (in unchanged order).\n -->\n<#assign priorities = [\n'name',\n'organizationName',\n'geo'\n]>\n\n<#-- Will not work for longer feature chains\n -->\n<#assign ignoreWhenOtherFeaturesPresent = {\n'commonNames': ['invalidAlert'],\n'commonAp': ['invalidAlert', 'commonNames'],\n'commonMp': ['invalidAlert', 'commonNames', 'commonAp']\n}>\n\n<#function calculatePriority featureName>\n    <#local index = priorities?seq_index_of(featureName)>\n\n    <#if index == -1>\n        <#return priorities?size>\n    </#if>\n\n    <#return index>\n</#function>\n\n<#function getSortedFeatures features>\n    <#return features\n    ?map(f -> { 'feature': f, 'priority': calculatePriority(f.name) })\n    ?sort_by('priority')\n    ?map(f -> f['feature'])>\n</#function>\n\n\n<#function shouldIgnoreDueToOtherFeatures feature featuresList>\n    <#if ignoreWhenOtherFeaturesPresent[feature.name]??>\n        <#list featuresList as otherFeature>\n            <#if ignoreWhenOtherFeaturesPresent[feature.name]?seq_contains(otherFeature.name)>\n                <#return true>\n            </#if>\n        </#list>\n    </#if>\n    <#return false>\n</#function>\n\n<#function getFeatureTemplate name>\n    <#local templateName = \"${name}Template\">\n    <#if .vars[templateName]??>\n        <#return .vars[templateName]>\n    <#else>\n        <#return .vars[\"missingAgentTemplate\"]>\n    </#if>\n</#function>\n\n<#function generateFeatureComments alertModel matchModel>\n    <#local features = []>\n    <#local matchFeatures = matchUtils.getMatchFeatures(matchModel)>\n\n    <#local features = features + getSortedFeatures(matchFeatures)\n    ?filter(f -> getFeatureTemplate(f.name)[\"isSolutionConsistent\"](alertModel, matchModel, f))>\n\n    <#local features = features + getSortedFeatures(matchFeatures)\n    ?filter(f -> !getFeatureTemplate(f.name)[\"isSolutionConsistent\"](alertModel, matchModel, f))>\n\n    <#local features = features?filter(f -> getFeatureTemplate(f.name)[\"shouldAdd\"](alertModel, matchModel, f))>\n\n    <#return features\n    ?filter(f -> !shouldIgnoreDueToOtherFeatures(f, features))\n    ?map(f -> getFeatureTemplate(f.name)[\"comment\"](alertModel, matchModel, f))>\n</#function>\n\n<#macro match alertModel matchModel>\n    ${stringUtils.join(generateFeatureComments(alertModel, matchModel), \" \")}<#t>\n</#macro>\n"
}
